<!-- saved from url=(0092)https://cryptonomic.tech/_matrix/media/r0/download/cryptonomic.tech/iMTLWSuCVJbIoqrjaBHKRXdl -->
<html>
    <head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<script
	    src="https://cdn.jsdelivr.net/gh/cryptonomic/conseiljs/dist-web/conseiljs.min.js"
	    integrity="sha384-1Lpjkva0cskGzGmrvU+WIbzNk24LwcaEFgsukzbI5wTl7T6kom1UA4DKS/oxtaqr"
	    crossorigin="anonymous">
	</script>

	<script>

	 const conseilServer = { url: 'https://conseil-dev.cryptonomic-infra.tech:443', apiKey: 'hooman' };
	 const platform = "tezos"
	 const network = "babylonnet"
	 
	 const stringOperators = [ { displayName: "is",   value: conseiljs.ConseilOperator.EQ }, 
				   { displayName: "in" , value: conseiljs.ConseilOperator.IN }, 
				   { displayName: "like", value: conseiljs.ConseilOperator.LIKE },
				   { displayName: "starts with", value: conseiljs.ConseilOperator.STARTSWITH },
				   { displayName:"ends with", value: conseiljs.ConseilOperator.ENDSWITH },
				   { displayName:"is null", value: conseiljs.ConseilOperator.ISNULL } ]
	 
	 const numberOperators = [ { displayName: "is",   value: conseiljs.ConseilOperator.EQ }, 
				   { displayName: "in" , value: conseiljs.ConseilOperator.IN }, 
				   { displayName: "between" , value: conseiljs.ConseilOperator.BETWEEN }, 
				   { displayName: "less than" , value: conseiljs.ConseilOperator.LT }, 
				   { displayName: "greater than" , value: conseiljs.ConseilOperator.GT } ]

	 const dateOperators = [ { displayName: "is",   value: conseiljs.ConseilOperator.EQ }, 
				 { displayName: "in" , value: conseiljs.ConseilOperator.IN }, 
				 { displayName: "between" , value: conseiljs.ConseilOperator.BETWEEN }, 
				 { displayName: "less than" , value: conseiljs.ConseilOperator.LT }, 
				 { displayName: "greater than" , value: conseiljs.ConseilOperator.GT },
				 { displayName: "before" , value: conseiljs.ConseilOperator.BEFORE }, 
				 { displayName: "after" , value: conseiljs.ConseilOperator.AFTER } ]

	 const stringDataTypes = [ "String", "Hash", "AccountAddress"]


	 let predicates = []

	 /* ========================== */
	 /* Dropdown menu manupulating */
	 /* ========================== */

	 function addOption(menu, text, value) {
	     var opt = document.createElement('option')
	     opt.value = value
	     opt.text = text
	     menu.options.add(opt)
	 }

	 function addOptions(menu, textAr, valueAr) {
	     menu.options.length = 0
	     addOption(menu, "pick a value", "pick a value")
	     for (i = 0; i < textAr.length; i++) {
		 addOption(menu, textAr[i], valueAr[i])
	     }
	 }

	 /* ================================== */
	 /* HTML Element creation and deletion */
	 /* ================================== */

	 function createMenuInBody(before) {
	     let newMenu = document.createElement("select")
	     let insertBefore = document.getElementById("results")
	     if (before) {
		 insertBefore = before
	     }
	     document.body.insertBefore(newMenu, insertBefore)
	     return newMenu
	 }

	 function createLabelInBody(before, content) {
	     let newLabel = document.createElement("label")
	     let insertBefore = document.getElementById("results")
	     newLabel.innerHTML = content
	     if (before) {
		 insertBefore = before
	     }
	     document.body.insertBefore(newLabel, insertBefore)
	     return newLabel
	 }

	 function createTextboxInBody(before) {
	     let newTextbox = document.createElement("input")
	     let insertBefore = document.getElementById("results")

	     newTextbox.setAttribute("type", "text")
	     if (before) {
		 insertBefore = before
	     }
	     document.body.insertBefore(newTextbox, insertBefore)

	     return newTextbox
	 }

	 function newAndMenu() {
	     let menu = createMenuInBody()
	     addOption(menu, "continue?", "continue?")
	     addOption(menu, "and", "and")
	     addOption(menu, ".", "end")
	     return menu
	 }

	 function deleteElement(element) {
	     element.parentNode.removeChild(element)
	 }

	 function deleteElementsIn(obj) {
	     let values = Object.values(obj)
	     for (element of values) {
		 deleteElement(element)
	     }
	 }

	 function resetValueElements(value) {
	     deleteElementsIn(value)
	     Object.keys(value).forEach(function(key) { delete value[key]; });
	 }

	 function deletePredicate(predicate) {
	     if (predicate.andMenu.options[1].value != "and") {
		 let nextPredicate = predicates[predicate.andMenu.options[1].value]
		 deletePredicate(nextPredicate)
	     }

	     predicates.splice(predicates.indexOf(predicate), 1)
	     resetValueElements(predicate.value)
	     deleteElement(predicate.attributeMenu)
	     deleteElement(predicate.operatorMenu)
	     deleteElement(predicate.label)
	     deleteElement(predicate.andMenu)
	 }

	 /* ================= */
	 /* Getter functions  */
	 /* ================= */

	 function getSelectedEntity() {
	     return document.getElementById("entities").value
	 }

	 function getObjectFromName(objArr, name) {
	     for (i = 0; i < objArr.length; i++) {
		 if (objArr[i].name == name) { return objArr[i] }
	     }
	 }

	 async function getAttributesForEntity(entity) {
	     const attributes = await conseiljs.ConseilMetadataClient.getAttributes(conseilServer, platform, network, entity)
	     return attributes
	 }

	 function getQuery() {
	     let query = conseiljs.ConseilQueryBuilder.blankQuery();
	     for (predicate of predicates) {
		 if (predicate.operatorMenu.value == conseiljs.ConseilOperator.BETWEEN) {
		     let beforeValue = parseInt(predicate.value.beforeElement.value) ?
				       parseInt(predicate.value.beforeElement.value) :
				       predicate.value.beforeElement.value

		     let afterValue = parseInt(predicate.value.afterElement.value) ?
				      parseInt(predicate.value.afterElement.value) :
				      predicate.value.afterElement.value
		     
		     query = conseiljs.ConseilQueryBuilder.addPredicate(query,
									predicate.attributeMenu.value,
									conseiljs.ConseilOperator.BEFORE,
									[beforeValue], false);
		     query = conseiljs.ConseilQueryBuilder.addPredicate(query,
									predicate.attributeMenu.value,
									conseiljs.ConseilOperator.AFTER,
									[afterValue], false);
		 }
		 else {
		     let value = parseInt(predicate.value.valueElement.value) ?
				 parseInt(predicate.value.valueElement.value) :
				 predicate.value.valueElement.value
		     query = conseiljs.ConseilQueryBuilder.addPredicate(query,
									predicate.attributeMenu.value,
									predicate.operatorMenu.value,
									[value], false);
		 }
	     }
	     return query
	 }

	 /* =============================================================================== */

	 function newPredicate() {
	     let andMenu = newAndMenu()
	     let label = createLabelInBody(andMenu, " where ")
	     let attributeMenu = createMenuInBody(andMenu)
	     let operatorMenu = createMenuInBody(andMenu)
	     let value = {}

	     let predicate = { "label" : label,
			       "attributeMenu" : attributeMenu,
			       "operatorMenu" : operatorMenu,
			       "value" : value,
			       "andMenu" : andMenu }

	     attributeMenu.onchange = function(){ updateOperatorMenu(predicate); }
	     operatorMenu.onchange = function() { updateValueElements(predicate) }
	     andMenu.onchange = function() { updateActivePredicates(predicate) }

	     predicates.push(predicate)
	     return predicate
	 }
	 
	 async function updateAttributeMenu(predicate) {
	     let menu = predicate.attributeMenu
	     const entity = getSelectedEntity()
	     const attributes = await getAttributesForEntity(entity)
	     const attributeDisplayNames = attributes.map( attribute => attribute.displayName )
	     const attributeNames = attributes.map( attribute => attribute.name  ) 

	     addOptions(menu, attributeDisplayNames, attributeNames)
	     
	 }
	 

	 async function updateOperatorMenu(predicate) {
	     let value = predicate.value
	     let attributeMenu = predicate.attributeMenu
	     let operatorMenu = predicate.operatorMenu

	     resetValueElements(value)

	     const selectedEntity = getSelectedEntity();
	     const attributes = await getAttributesForEntity(selectedEntity)
	     const attributeDataType = getObjectFromName(attributes, attributeMenu.value).dataType

	     const  operatorsAvailable = (stringDataTypes.includes(attributeDataType)) ?
					 stringOperators :
					 (attributeDataType == "DateTime") ?
					 dateOperators :
					 numberOperators

	     const operatorDisplayNames = operatorsAvailable.map( operator => operator.displayName )
	     const operatorValues = operatorsAvailable.map( operator => operator.value )

	     addOptions(operatorMenu, operatorDisplayNames, operatorValues)

	 }

	 async function updateValueElements(predicate) {
	     let value = predicate.value
	     let attributeMenu = predicate.attributeMenu
	     let operatorMenu = predicate.operatorMenu
	     let andMenu = predicate.andMenu

	     resetValueElements(value)

	     const entity = getSelectedEntity()
	     const attributes = await getAttributesForEntity(entity)
	     const attributeObject = getObjectFromName(attributes, attributeMenu.value)
	     const cardinality = attributeObject.cardinality
	     const cardinalityThreshold = 20
	     console.log(cardinality)
	     console.log(attributeObject)
	     if (operatorMenu.value == conseiljs.ConseilOperator.BETWEEN) {
		 value["afterElement"] = createTextboxInBody(andMenu)
		 value["labelElement"] = createLabelInBody(andMenu, " and ")
		 value["beforeElement"] = createTextboxInBody(andMenu)

	     }
	     else if (cardinality < cardinalityThreshold
		      && operatorMenu.value == conseiljs.ConseilOperator.EQ ) {

		 let valueMenu = createMenuInBody(andMenu)
		 const attributeValues = await conseiljs.ConseilMetadataClient.getAttributeValues(conseilServer, platform,
												  network, entity,
												  attributeMenu.value )
		 addOptions(valueMenu, attributeValues, attributeValues)
		 value["valueElement"] = valueMenu
	     }
	     else { 
		 value["valueElement"] = createTextboxInBody(andMenu) 
	     }
	 }


	 function updateActivePredicates(predicate) {
	     let andMenu = predicate.andMenu
	     if (andMenu.value == "and") {
		 let newPred = newPredicate()
		 updateAttributeMenu(newPred)
		 andMenu.options[1].value = predicates.indexOf(newPred)
	     }
	     else if (andMenu.value == "end" && andMenu.options[1].value != "and") {
		 deletePredicate(predicates[andMenu.options[1].value])
		 andMenu.options[1].value = "and"
	     }
	 }

	 function resetPredicates() {
	     let firstPredicate = predicates[0]
	     deletePredicate(firstPredicate)
	     updateAttributeMenu(newPredicate())
	 }

	 async function initialize() {
	     let entityMenu = document.getElementById("entities")

	     entityMenu.onchange = resetPredicates

	     const entities = await conseiljs.ConseilMetadataClient.getEntities(conseilServer, platform, network)
	     entityNames = entities.map( entity => entity.name )
	     entityDisplayNames = entities.map( entity => entity.displayName ) 
	     addOptions(entityMenu, entityDisplayNames, entityNames)

	     newPredicate()

	 }
	 

	 async function executeQuery() {
	     let query = getQuery()
	     let response = await conseiljs.ConseilDataClient.executeEntityQuery(conseilServer,
										 platform,
										 network,
										 getSelectedEntity(),
										 query);

	     document.getElementById("results").innerHTML = JSON.stringify(response)
	 }
	 
	</script>
	
    </head>
    
    <body onload="initialize()">
	<button onclick="executeQuery()">Send</button><br><br>
	<label for="entities">Show</label>
	<select id="entities">	</select>


	<p id="results"> </p>

    </body>


</html>
